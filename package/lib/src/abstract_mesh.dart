part of babylon_dart;

/// class AbstractMesh
@JS()
class AbstractMesh extends TransformNode implements IDisposable, ICullable, IGetSetVerticesData {
  // properties
  external num OCCLUSION_TYPE_NONE;
  external num OCCLUSION_TYPE_OPTIMISTIC;
  external num OCCLUSION_TYPE_STRICT;
  external num OCCLUSION_ALGORITHM_TYPE_ACCURATE;
  external num OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE;
  external static final Object CULLINGSTRATEGY_STANDARD;
  external static final Object CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
  external static final Object CULLINGSTRATEGY_OPTIMISTIC_INCLUSION;
  external static final Object CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY;
  external num cullingStrategy;
  external Observable<AbstractMesh> onCollideObservable;
  external Observable<Vector3> onCollisionPositionChangeObservable;
  external Observable<AbstractMesh> onMaterialChangedObservable;
  external bool definedFacingForward;
  external num alphaIndex;
  external bool isVisible;
  external bool isPickable;
  external bool isNearPickable;
  external bool isNearGrabbable;
  external bool showSubMeshesBoundingBox;
  external bool isBlocker;
  external bool enablePointerMoveEvents;
  external Color3 outlineColor;
  external num outlineWidth;
  external Color3 overlayColor;
  external num overlayAlpha;
  external bool useOctreeForRenderingSelection;
  external bool useOctreeForPicking;
  external bool useOctreeForCollisions;
  external bool alwaysSelectAsActiveMesh;
  external bool doNotSyncBoundingInfo;
  external AbstractActionManager? actionManager;
  external Vector3 ellipsoid;
  external Vector3 ellipsoidOffset;
  external num edgesWidth;
  external Color4 edgesColor;
  external List<SubMesh> subMeshes;
  external Observable<AbstractMesh> onRebuildObservable;
  // methods
  external Material? getMaterialForRenderPass(num renderPassId);
  external void setMaterialForRenderPass(num renderPassId, [Material material]);
  external void transferToEffect(Matrix world);
  external UniformBuffer getMeshUniformBuffer();
  external String getClassName();
  external String toString([bool fullDetails]);
  external AbstractMesh markAsDirty([String property]);
  external void resetDrawCache([num passId]);
  external AbstractMesh? getLOD(Camera camera);
  external num getTotalVertices();
  external num getTotalIndices();
  external Int32List? getIndices([bool copyWhenShared, bool forceCopy]);
  external Float32List? getVerticesData(String kind, [bool copyWhenShared, bool forceCopy]);
  external AbstractMesh setVerticesData(String kind, Float32List data, [bool updatable, num stride]);
  external AbstractMesh updateVerticesData(String kind, Float32List data, [bool updateExtends, bool makeItUnique]);
  external AbstractMesh setIndices(Int32List indices, num? totalVertices, [bool updatable]);
  external bool isVerticesDataPresent(String kind);
  external BoundingInfo getBoundingInfo();
  external AbstractMesh setBoundingInfo(BoundingInfo boundingInfo);
  external BoundingInfo buildBoundingInfo(Vector3 minimum, Vector3 maximum, [Matrix worldMatrix]);
  external AbstractMesh normalizeToUnitCube([bool includeDescendants, bool ignoreRotation, bool Function(AbstractMesh node)? predicate]);
  external Matrix getWorldMatrix();
  external AbstractMesh movePOV(num amountRight, num amountUp, num amountForward);
  external Vector3 calcMovePOV(num amountRight, num amountUp, num amountForward);
  external AbstractMesh rotatePOV(num flipBack, num twirlClockwise, num tiltRight);
  external Vector3 calcRotatePOV(num flipBack, num twirlClockwise, num tiltRight);
  external AbstractMesh refreshBoundingInfo([bool applySkeleton, bool applyMorph]);
  external Float32List? getNormalsData([bool applySkeleton, bool applyMorph]);
  external Float32List? getPositionData([bool applySkeleton, bool applyMorph, Float32List? data]);
  external bool isInFrustum(List<Plane> frustumPlanes);
  external bool isCompletelyInFrustum(List<Plane> frustumPlanes);
  external bool intersectsMesh(Object mesh, [bool precise, bool includeDescendants]);
  external bool intersectsPoint(Vector3 point);
  external AbstractMesh moveWithCollisions(Vector3 displacement);
  external PickingInfo intersects(Ray ray, [bool fastCheck, TrianglePickingPredicate trianglePredicate, bool onlyBoundingInfo, Matrix worldToUse, bool skipBoundingInfo]);
  external AbstractMesh? clone(String name, Node? newParent, [bool doNotCloneChildren]);
  external AbstractMesh releaseSubMeshes();
  external void dispose([bool doNotRecurse, bool disposeMaterialAndTextures]);
  external AbstractMesh addChild(AbstractMesh mesh, [bool preserveScalingSign]);
  external AbstractMesh removeChild(AbstractMesh mesh, [bool preserveScalingSign]);
  external AbstractMesh updateFacetData();
  external List<Vector3> getFacetLocalNormals();
  external List<Vector3> getFacetLocalPositions();
  external List<List<num>> getFacetLocalPartitioning();
  external Vector3 getFacetPosition(num i);
  external AbstractMesh getFacetPositionToRef(num i, Vector3 ref);
  external Vector3 getFacetNormal(num i);
  external THIS getFacetNormalToRef<THIS extends AbstractMesh>(num i, Vector3 ref);
  external List<num>? getFacetsAtLocalCoordinates(num x, num y, num z);
  external num? getClosestFacetAtCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);
  external num? getClosestFacetAtLocalCoordinates(num x, num y, num z, [Vector3 projected, bool checkFace, bool facing]);
  external Object getFacetDataParameters();
  external AbstractMesh disableFacetData();
  external AbstractMesh updateIndices(Int32List indices, [num offset, bool gpuMemoryOnly]);
  external AbstractMesh createNormals(bool updatable);
  external AbstractMesh alignWithNormal(Vector3 normal, [Vector3 upDirection]);
  external AbstractMesh disableEdgesRendering();
  external AbstractMesh enableEdgesRendering([num epsilon, bool checkVerticesInsteadOfIndices, IEdgesRendererOptions options]);
  external List<IParticleSystem> getConnectedParticleSystems();
}
